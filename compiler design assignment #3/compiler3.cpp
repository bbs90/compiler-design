/*
 * B.Bhargav Sastry
 * COSC 5390.001   
 * Programming Language
 * COURSE ASSIGNMENT III
 * Fall 2015
 */


#include <iostream>
#include <fstream>
#include <string>
#include <sstream>

using namespace std;

string word;
/* The output of this program is written in file output.txt*/
ofstream op("output.txt");
int lex_state=1;
void part2(int a[][14]);
int tok1=0;
int tok=0;


/* This function exectues 
 * Statement -> id = {print(id.lexeme)} Expression {print(‘=’)} ;
 */ 
bool s();

/* This function exectues 
 * Expression -> Term Moreterms
 */ 
bool e();

/* This function exectues 
 * Moreterms -> + Term {print(‘+’)} Moreterms
 * | - Term {print(‘-’)} Moreterms
 * | episilon
 */ 
bool mt(); 

/* This function exectues 
 * Term -> Factor Morefactors
 */ 
bool t();

/* This function exectues 
 * Value -> ( Expression )
 * | id {print(id.lexeme)}
 * | num {print(num.value)}
 */ 
bool v(); 

/* This function exectues 
 * Morefactors -> * Factor {print(‘*’)} Morefactors
 * | / Factor {print(‘/’)} Morefactors
 * | div Factor {print(‘div’)} Morefactors
 * | mod Factor {print(‘mod’)} Morefactors
 */
bool mf();
 
/* This function exectues 
 * Factor -> Base ^ Factor {print(‘^’)}
 * | Base
 */ 
bool f();

/* This function exectues 
 * Base -> # Value {print(‘#’)}
 * | ~ Value {print(‘~’)}
 * | Value
 */
bool b();

/* This function exectues 
 * gets tokens from the file data.txt which is 
 * generated by the function part2(int a[][14]);
 */ 
string getexp();

/* This function backs up the pointer, which is used by 
 * the function getexp() to return the tokens, by one
 */   
void backup();

/* This function is from assignment II. It reads the input 
 * and makes a file called data.txt, which contains all
 * the tokens present in the input file Lab3.txt.
 */ 
void part2(int a[][14]);

int main()
{
	
	string ln, store, lin, q;
	int  a[21][14], i=0, j=0, num;
	ifstream ip0("Lab3.txt");
	ifstream ip("table.txt");
	for(i=0;i<21;i++)
	{
		for(j=0;j<14;j++)
		{
			ip>>num;
			a[i][j]=num;
		}
	}
	
	part2(a);
	ifstream ip3("data.txt");	
	while(!ip3.eof())
	{
		getline(ip3, q);
		num++;
	}
	
	while(i<num)
	{
		s();
		i++;
	}
	
}

bool s()
{
	int i=0;
	string cc, c;
	cc=getexp();
	if(isalpha(cc[0]))
	{
		c=cc;
		cc=getexp();
		if(cc=="=")
		{
			op<<c<<" ";
			if(e())
			{
				i=1;
				op<<" = "<<endl<<endl;
			}
		}
	}
	return i;
}

bool e()
{
	int i=0;
	if(t())
	{
		if(mt())
		{
			i=1;
		}
	}
	return i;
}

bool t()
{
	int i=0;
	if(f())
	{
		if(mf())
		{
			i=1;
		}
	}
	return i;
}

bool mt()
{
	string cc;
	int i=0;
	
	cc=getexp();
	
	if(cc=="+")
	{
		if(t())
		{
			op<<" + ";
			if(mt())
			{
				i=1;
			}
		}
	}
	else if(cc=="-")
	{
		if(t())
		{
			op<<" - ";
			if(mt())
			{
				i=1;
			}
		}
	}
	else 
	{
		if(cc==")" || cc==";")
		{
			backup();
			i=1;
		}
	}
	return i;
}

bool v() 
{
	int i=0;
	string cc;
	cc=getexp();
	if(cc=="(")
	{
		if(e())
		{
			i=1;
		}
		cc=getexp();
		if(cc==")")
		{
			i=1;
		}
	}
	else if(isalpha(cc[0]))
	{
		op<<cc<<" ";
		i=1;
	}
	else if(isdigit(cc[0]))
	{
		op<<cc<<" ";
		i=1;
	}
	return i;
}

bool mf()
{
	int i=0;
	string cc;
	cc=getexp();
	if(cc=="*")
	{
		if(f())
		{
			op<<" * ";
			if(mf())
			{
				i=1;
			}
		}
	}
	else if(cc=="/")
	{
		if(f())
		{
			op<<" / ";
			if(mf())
			{
				i=1;
			}
		}
	}
	else if(cc=="div")
	{
		if(f())
		{
			op<<" div ";
			if(mf())
			{
				i=1;
			}
		}
	}
	else if(cc=="mod")
	{
		if(f())
		{
			op<<" mod ";
			if(mf())
			{
				i=1;
			}
		}
	}
	else
	{
		if(cc=="+" || cc==")" || cc==";" || cc=="-")
		{
			backup();
			i=1;
		}
	}
	return i;
}

bool f()
{
	int i=0;
	string cc;
	if(b())
	{
		cc=getexp();
		if(cc=="^")
		{
			if(f())
			{
				i=1;
				op<<" ^ ";
			}
		}
		else
		{
			if(cc=="*" || cc=="/" || cc=="div" || cc=="mod" || cc=="+" || cc=="-" || cc==";" || cc==")");
			{
				i=1;
				backup();
			}
		}
	}

	
	return i;
}

bool b()
{
	int i=0;
	string cc;
	cc=getexp();
	if(cc=="#")
	{
		if(v())
		{
			i=1;
			op<<" # ";
		}
	}
	else if(cc=="~")
	{
		if(v())
		{
			i=1;
			op<<" ~ ";
		}
		
	}
	else
	{
		backup();
		if(v())
		{
			i=1;
		}
			
	}
	return i;
}
	


void part2(int a[][14])
{
	int i=0,k,cp=0;
	char store[200], temp1, temp2;
	
	string m;
	string col = "{}(*):=<>";
	
	string pun = ";.,+-/*^[]\'\"#$";

	string tok, lin;
	ifstream ip2("Lab3.txt");
	ofstream op("data.txt");
	
	lex_state=1;
	while(!ip2.eof())                    
	{								
		
		getline(ip2, lin);
		for(cp=0;lin[cp]!='\0';cp++)
		{
			
			store[i]=lin[cp];
			if(isalpha(lin[cp]))
			{
				lex_state=a[lex_state][1];		
			}
			if(isdigit(lin[cp]))
			{
				lex_state=a[lex_state][2];
			}
			if(ispunct(lin[cp]))
			{
				int fl=1;
				temp2=lin[cp];
				for(k=0;k<9;k++)
				{
					temp1=col[k];
					if(temp1==temp2)
					{	
						fl=0;
					}
				}

				if(fl)
				{
					lex_state=a[lex_state][13];
				}
		
			}
			
			if(isspace(lin[cp]))
			{
				lex_state=a[lex_state][12];
			}
			for(k=0;k<9;k++)
			{
				temp1=col[k];
				temp2=lin[cp];
				if(temp1==temp2)
				{	
					lex_state=a[lex_state][k+3];
				}
			}
			
			switch(lex_state)
			{
				// state 3 for accepting identifers and keyword.
				case 3:
				{
				
					tok='\0';
					store[i]='\0';
					tok=store;
					while(isspace(tok[0]))
					{
						tok=tok.substr(1, tok.size());
					}
					/* Since we need to back up in state 3
					 * cp-- is done. This is implemented
					 * logically and not taken from the
					 * symbol table
					 */ 
					cp--;
					i=-1;
					op<<tok<<endl;
					store[0]='\0';
					lex_state=1;
				}
				break;
				//case 5 for accepting constants
				case 5:
				{
					tok='\0';
					store[i]='\0';
					i=-1;
					tok=store;
					while(isspace(tok[0]))
					{
						tok=tok.substr(1, tok.size());
					}
					/* Since we need to back up in state 5
					 * cp-- is done. This is implemented
					 * logically and not taken from the
					 * symbol table
					 */ 
					cp--;
					op<<tok<<endl;
					store[0]='\0';
					lex_state=1;
				}
				break;
				// state 7 takes coments but does not ptint then
				// into the file as comments are not required.
				case 7:
				{
					store[0]='\0';
					i=-1;
					lex_state=1;
				}
				break;
				// state 11 aslo takes coments but does not ptint 
				// them into the file as comments are not 
				// required.
				case 11:
				{
					store[0]='\0';
					i=-1;
					lex_state=1;
				}
				break;
				// case 13 accepts assignment operator.
				case 13:
				{
					tok='\0';
					store[i+1]='\0';
					i=-1;
					tok=store;
					while(isspace(tok[0]))
					{
						tok=tok.substr(1, tok.size());
					}
					op<<tok<<endl;
					store[0]='\0';
					lex_state=1;
				}
				break;
				// case 15 accepts relational operator.
				case 15:
				{
					tok='\0';
					store[i+1]='\0';
					i=-1;
					tok=store;
					while(isspace(tok[0]))
					{
						tok=tok.substr(1, tok.size());
					}
					op<<tok<<endl;
					store[0]='\0';
					lex_state=1;
				}
				break;
				// case 16 accepts relational operator.
				case 16:
				{
					tok='\0';
					store[i+1]='\0';
					i=-1;
					tok=store;
					while(isspace(tok[0]))
					{
						tok=tok.substr(1, tok.size());
					}
					op<<tok<<endl;
					store[0]='\0';
					lex_state=1;
				}
				break;
				// case 18 accepts relational operator.
				case 18:
				{
					tok='\0';
					store[i+1]='\0';
					i=-1;
					tok=store;
					while(isspace(tok[0]))
					{
						tok=tok.substr(1, tok.size());
					}
					op<<tok<<endl;
					store[0]='\0';
					lex_state=1;
				}
				break;
				// case 19 accepts general punction.
				case 19:
				{
					tok='\0';
					store[i+1]='\0';
					tok=store;
					while(isspace(tok[0]))
					{
						tok=tok.substr(1, tok.size());
					}
					
					op<<tok<<endl;	
					store[0]='\0';
					lex_state=1;
					i=-1;
				}
				break;
				// case 20 accepts general punction.
				case 20:
				{
					tok='\0';
					store[i]='\0';
					i=-1;
					tok=store;
					/* Since we need to back up in state 20
					 * cp-- is done. This is implemented
					 * logically and not taken from the
					 * symbol table
					 */ 
					cp--;
					while(isspace(tok[0]))
					{
						tok=tok.substr(1, tok.size());
					}
					
					op<<tok<<endl;	
					store[0]='\0';
					lex_state=1;
					i=-1;
				}
				break;
			}
			i++;
		}
/*
 * This part of the code will execute if end of line has been reached
 * while lex_state value is "2". The value of "2" means that the 
 * current state is 2 which is for accepting identifers and keyword.
 * For example 
 * begin
 * 	if(...
 * 
 * Here begin is a keyword. The function takes the entire line 
 * and starts at "b" and continues to accept characters till it as 
 * reached the end of line. Before going to the next line the token
 * "begin" must be accepted since end of line is considered as 
 * white space according to the symbol table and transition 
 * must be made.
 * 
 * This transition cannot be made in the for loop  given above
 * as the loop exits when it encounters the end of line and 
 * moves to the next line.
 */ 		
		if((lex_state==2))
		{
			tok='\0';
			store[i]='\0';
			tok=store;
			while(isspace(tok[0]))
			{
				tok=tok.substr(1, tok.size());
			}
			i=-1;
			op<<tok<<endl;
			store[0]='\0';
			lex_state=1;
		}
		i=0;
	}
}


string getexp()
{
	int t;
	string a;
	ifstream ip1("data.txt");	
	for(t=0; t<=tok1;t++)
		getline(ip1, a);
	tok1++;
	return a;
}

void backup()
{
	if(tok1>0)
		tok1--;
}

