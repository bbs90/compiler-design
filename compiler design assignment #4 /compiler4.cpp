/*
 * B.Bhargav Sastry
 * COSC 5390.001   
 * Compiler Design
 * COURSE ASSIGNMENT III
 * Fall 2015
 */


#include <iostream>
#include <fstream>
#include <string>
#include <sstream>


using namespace std;

string word;

int tn=0, tnl=0;

int lex_state=1;
void part2(int a[][14]);
int tok1=0;
int tok=0;
/*This class is used to implement 
 * functions given in Lab Assignment IV Addendum(1).pdf
 */ 
class ac
{
	char t[2], l[2];
	ac *link;
	public:
	string alloc();
	string lalloc();
	void penta(string o, string op1, string op2, string op3, string r);
	void quad(string a, string b, string c, string d);
	void tri(string a, string b, string c);
	void duo(string a, string b);
	void clear();
	void lclear();
	ac();
};
ac *first=NULL, *sec=NULL;

ac::ac()
{
	t[0]='T';
	t[1]=' ';
	t[2]=' ';
	l[0]='L';
	l[1]=' ';
	l[2]=' ';
}

string ac::alloc()
{
	string ret;
	stringstream ss;
	char te[2];
	int tl, u, d;
	tl=tn;
	tn++;
	ac *temp, *i;
	temp = new ac;
	
	if(tl<=9)
	{	
		// ASCII value of char 0 is 48
		temp->t[1]=tl+48;
	}
	else
	{
		d=tl/10;
		u=tl%10;
		// ASCII value of char 0 is 48
		temp->t[1]=d+48;
		temp->t[2]=u+48;
		
	}

	temp->link = NULL;
	if(first==NULL)
	{
		first=temp;
	}
	else
	{
		for(i=first;(i->link!=NULL); i=i->link);
		if((i->link==NULL))
			i->link=temp;
	}
	
	
	te[0]=temp->t[0];
	te[1]=temp->t[1];
	te[2]=temp->t[2];
	te[3]=' ';
	ss<<te;
	ss>>ret;
	
	return ret;
}


string ac::lalloc()
{
	string ret;
	stringstream ss;
	char te[2];
	int tl, u, d;
	tl=tnl;
	tnl++;
	ac *temp1, *i;
	temp1 = new ac;
	
	if(tl<=9)
	{	
		
		temp1->l[1]=tl+48;
	}
	else
	{
		d=tl/10;
		u=tl%10;
		// ASCII value of char 0 is 48
		temp1->l[1]=d+48;
		temp1->l[2]=u+48;
		
	}
	
	temp1->link = NULL;
	if(sec==NULL)
	{
		sec=temp1;
	}
	else
	{
		for(i=sec;(i->link!=NULL); i=i->link);
		if((i->link==NULL))
			i->link=temp1;
	}

	
	te[0]=temp1->l[0];
	te[1]=temp1->l[1];
	te[2]=temp1->l[2];
	te[3]=' ';
	ss<<te;
	ss>>ret;

	return ret;
}


void ac::clear()
{
	ac *temp;
	
	while( first!=NULL )
	{
		temp=first->link;
		delete(first);
		first = temp;
		
	}
	tn = 0;
}

void ac::lclear()
{
	ac *temp1;

	while(sec!=NULL)
	{
		temp1=sec->link;
		delete(sec);
		sec=temp1;
	}
	tnl=0;
}

void ac::penta(string o, string op1, string op2, string op3, string r)
{	
	ofstream op("output.txt", ios::app );
	op<<"( "<<o<<" "<<op1<<", "<<op2<<", "<<op3<<", "<<r<<" )"<<endl;
} 

void ac::duo(string o, string op1)
{
	ofstream op("output.txt", ios::app );
	op<<"( "<<o<<" "<<op1<<" )"<<endl;
} 

void ac::quad(string o, string op1, string op2, string r)
{	
	ofstream op("output.txt", ios::app );
	op<<"( "<<o<<" "<<op1<<", "<<op2<<", "<<r<<" )"<<endl;
	
} 

void ac::tri(string o, string op12, string r0)
{
	ofstream op("output.txt", ios::app );
	op<<"( "<<o<<" "<<op12<<", "<<r0<<" )"<<endl;
} 


ac sv;

/* This function executes
 * Program → program Stmt_list end . eof
 */ 
 
void p();

/*This function executes
 * id p = Expr q {MOV}q,p | if Expr p compare c Expr q {TST} p,q,c,L {JMP} L then {LBL} L Stmt {LBL} L 
 * | while {LBL} L Expr p compare c Expr q {TST} p,q,c,L {JMP} L do {LBL} L Stmt {JMP} L {LBL} L
 */ 
void s();

/*This function executes
 * Stmt_list → Stmt ; Stmt_list | ∈
 */
string sl();

/* This function exectues 
 * Expression -> Term Moreterms
 */
string e();

/* This function exectues 
 * Term p → Factor q Morefactors q,p
 */
string t();

/* This function exectues
 *  Moreterms p,q → + Term t {ADD}p,t,r Moreterms r,q 
 * | - Term t {SUB}p,t,r Moreterms r,q 
 * | ∈
 */ 
string mt(string q);

/* This function exectues
 * Factor p → Base p ^ Factor t {EXP}p,t,r | Base p
 */ 
string f();

/* This function exectues
 * Morefactors p,q → * Factor t {MUL}p,t,r Morefactors r,q 
 * | / Factor t {DVD}p,t,r Morefactors r,q
 * | div Factor t {DIV}p,t,r Morefactors r,q
 * | mod Factor t {MOD}p,t,r Morefactors r,q
 * |∈
 */ 
string mf(string q) ;

/*This function executes
 *Base p → # Value p {PLS}p,r
 * | ~ Value p {NEG}p,r
 * | Value p 
 */  
string b();

/*This function executes
 * Value p → ( Expr p )
 * | id p
 * | num p
 */ 
string v();

/* This function exectues 
 * gets tokens from the file data.txt which is 
 * generated by the function part2(int a[][14]);
 */ 
string getexp();

/* This function backs up the pointer, which is used by 
 * the function getexp() to return the tokens, by one
 */     
void backup();

/* This function is from assignment II. It reads the input 
 * and makes a file called data.txt, which contains all
 * the tokens present in the input file Lab3.txt.
 */ 
void part2(int a[][14]);

int main()
{
	
	string ln, store, lin, q;
	int  a[21][14], i=0, j=0, num;
	ifstream ip0("Lab3.txt");
	ifstream ip("table.txt");
	ofstream op("output.txt", ios::app );
	for(i=0;i<21;i++)
	{
		for(j=0;j<14;j++)
		{
			ip>>num;
			a[i][j]=num;
		}
	}
	
	part2(a);

	p();
	
}

void p()
{
	string cc;
	cc=getexp();
	if(cc=="program")
	{	
		cc=sl();
		cc=getexp();//taking in "."
	}
	//eof
}

void s()
{

	string cc, c, lv1, lv2, c2, lv3;
	string qv, pv, lv, o;
	cc=getexp();

	if(isalpha(cc[0]))
	{
		if(cc!="if" && cc!="while" )
		{	
			c=cc;
			cc=getexp();
			
			if(cc=="=")
			{
				qv=e();
				
				o="MOV";
				sv.tri(o,qv,c);	
			}
		}
		else if(cc=="if")
		{
			pv=e();
			
			
			cc=getexp();
	
			qv=e();
			
			c2=getexp(); //consumes the token "then" 
			
			o="TST";
			lv=sv.lalloc();
		
			sv.penta(o, pv, cc, qv, lv);
			lv1=sv.lalloc();
			o="JMP";
			sv.duo(o, lv1);
			o="LBL";
			
			sv.duo(o, lv);
		
			s();
			
			
			o="LBL";
			
			sv.duo(o, lv1);
			sv.lclear();
		}
		else if(cc=="while")
		{
			
			string lv1, lv2,pv;
			o="LBL";
			lv=sv.lalloc();
			lv1=lv;
			sv.duo(o, lv);
			pv=e();
			
			c=getexp();
			
			qv=e();
			o="TST";
			lv=sv.lalloc();
			lv2=lv;
			sv.penta(o, pv, c, qv, lv2);
			lv2=sv.lalloc();
			lv3=lv2;
			o="JMP";
			sv.duo(o, lv2);
			cc=getexp(); //consumes the token "do"
		
				o="LBL";
				
				sv.duo(o, lv);
				s();
				o="JMP";
				
				sv.duo(o, lv1);
				o="LBL";
				
				sv.duo(o, lv3);
			sv.lclear();
		}
		
	}
	else if(cc==";")
	{
		backup();
	}
	
}

string sl()
{
	string cc;
	ofstream op("output.txt", ios::app );
	cc=getexp();
	if(cc!="end")
	{
		backup();
		s();
		cc=getexp();
	
		if(cc==";")
		{
			sv.clear();
			op<<endl;
			sl();
		}
		
	}
	else if(cc=="end")
	{
		backup();
	}
	return cc;
}

string e()
{
	string qv;
	
	qv=t();
	{
	
		qv=mt(qv);
		
	}
	return qv;
}

string mt(string q)
{
	string cc;
	string rv, tv, qv,o;
	
	cc=getexp();

	if(cc=="+")
	{
		tv=t();
		{
			
			o="ADD";
			rv=sv.alloc();
			
			sv.quad(o,q,tv,rv);
			qv=mt(rv);
			rv=qv;
		}
	}
	else if(cc=="-")
	{
		tv=t();
		{
			
			o="SUB";
			rv=sv.alloc();
			sv.quad(o,q,tv,rv);
			qv=mt(rv);
			
		}
	}
	else 
	{	
		if(cc==")" || cc==";" || cc=="=" || cc==">=" || cc=="<=" || cc=="<>" || cc=="<" || cc==">" || cc=="then" || cc=="do")
		{
			backup();
			
			rv=q;
			
		}
	}
	
	return rv;
}


string t()
{
	string qv, pv;
	
	qv=f();
	pv=mf(qv);
	return pv;
}

string mf(string q)
{
	
	string cc;
	string rv, tv, qv, o;
	cc=getexp();
	if(cc=="*")
	{
		tv=f();
		{
			
			o="MUL";
			rv=sv.alloc();
			sv.quad(o,q,tv,rv);
			qv=mf(rv);
			{
				rv=qv;
			}
		}
	}
	else if(cc=="/")
	{
		tv=f();
		{
			o="DVD";
			rv=sv.alloc();
			sv.quad(o,q,tv,rv);
			qv=mf(rv);
			{
				rv=qv;
				
			}
		}
	}
	else if(cc=="div")
	{
		tv=f();
		{
			
			o="DIV";
			rv=sv.alloc();
			sv.quad(o,q,tv,rv);
			qv=mf(rv);
			{
				rv=qv;
			}
		}
	}
	else if(cc=="mod")
	{
		tv=f();
		{
			o="MOD";
			rv=sv.alloc();
			sv.quad(o,q,tv,rv);
			qv=mf(rv);
			{
				rv=qv;
			}
		}
	}
	else
	{
		if(cc==")" || cc==";" || cc=="=" || cc==">=" || cc=="<=" || cc=="<>" || cc=="<" || cc==">" || cc=="then" || cc=="do"||cc=="+"||cc=="-")
		{
			backup();
			rv=q;
		}
	}

	return rv;

}



string f()
{
	int i=0;
	string cc, c;
	string pv, rv, tv, qv, o, lv;
	c=b();
	
	{
		cc=getexp();
	
		if(cc=="^")
		{
			pv=f();
			
			{
				o="EXP";
				rv=sv.alloc();
				sv.quad(o, c, pv, rv);
				pv=rv;
			}
		}
		else
		{
			
			if(cc=="*" || cc=="/" || cc=="div" || cc=="mod" || cc=="+" || cc=="-" || cc==";" || cc==")" || cc=="="||cc=="then"||cc=="do");
			{
				i=1;
				backup();
			}
		}
	}
	
	if(i==1)
		return c;
	return pv;
}

string b()
{
	string cc;
	string pv, rv, tv, qv, o, lv;
	cc=getexp();

	if(cc=="#")
	{
		pv=v();
		rv=sv.alloc();
		o="PLS";
		sv.tri(o, pv, rv);
		pv=rv;
	}
	else if(cc=="~")
	{
		pv=v();
		{
			rv=sv.alloc();
			o="NEG";
			sv.tri(o, pv, rv);
			pv=rv;
		}
		
	}
	else
	{
		backup();
		cc=v();
		pv=cc;
	}
	
	return pv;
}


string v() 
{

	string cc;
	string pv;
	cc=getexp();

	if(cc=="(")
	{
		pv=e();

		
		cc=getexp(); //cc consumes the token ")"
		if(cc==")")
		{
			
		}
	}
	else if(isalpha(cc[0]))
	{
		pv=cc;
	}
	else if(isdigit(cc[0]))
	{
		pv=cc;
	}

	return pv;
}


void part2(int a[][14])
{
	int i=0,k,cp=0;
	char store[200], temp1, temp2;
	
	string m;
	string col = "{}(*):=<>";
	
	string pun = ";.,+-/*^[]\'\"#$";

	string tok, lin;
	ifstream ip2("Lab3.txt");
	ofstream op("data.txt");
	
	lex_state=1;
	while(!ip2.eof())                    
	{								
		
		getline(ip2, lin);
		for(cp=0;lin[cp]!='\0';cp++)
		{
			
			store[i]=lin[cp];
			if(isalpha(lin[cp]))
			{
				lex_state=a[lex_state][1];		
			}
			if(isdigit(lin[cp]))
			{
				lex_state=a[lex_state][2];
			}
			if(ispunct(lin[cp]))
			{
				int fl=1;
				temp2=lin[cp];
				for(k=0;k<9;k++)
				{
					temp1=col[k];
					if(temp1==temp2)
					{	
						fl=0;
					}
				}

				if(fl)
				{
					lex_state=a[lex_state][13];
				}
		
			}
			
			if(isspace(lin[cp]))
			{
				lex_state=a[lex_state][12];
			}
			for(k=0;k<9;k++)
			{
				temp1=col[k];
				temp2=lin[cp];
				if(temp1==temp2)
				{	
					lex_state=a[lex_state][k+3];
				}
			}
			
			switch(lex_state)
			{
				// state 3 for accepting identifers and keyword.
				case 3:
				{
				
					tok='\0';
					store[i]='\0';
					tok=store;
					while(isspace(tok[0]))
					{
						tok=tok.substr(1, tok.size());
					}
					/* Since we need to back up in state 3
					 * cp-- is done. This is implemented
					 * logically and not taken from the
					 * symbol table
					 */ 
					cp--;
					i=-1;
					op<<tok<<endl;
					store[0]='\0';
					lex_state=1;
				}
				break;
				//case 5 for accepting constants
				case 5:
				{
					tok='\0';
					store[i]='\0';
					i=-1;
					tok=store;
					while(isspace(tok[0]))
					{
						tok=tok.substr(1, tok.size());
					}
					/* Since we need to back up in state 5
					 * cp-- is done. This is implemented
					 * logically and not taken from the
					 * symbol table
					 */ 
					cp--;
					op<<tok<<endl;
					store[0]='\0';
					lex_state=1;
				}
				break;
				// state 7 takes coments but does not ptint then
				// into the file as comments are not required.
				case 7:
				{
					store[0]='\0';
					i=-1;
					lex_state=1;
				}
				break;
				// state 11 aslo takes coments but does not ptint 
				// them into the file as comments are not 
				// required.
				case 11:
				{
					store[0]='\0';
					i=-1;
					lex_state=1;
				}
				break;
				// case 13 accepts assignment operator.
				case 13:
				{
					tok='\0';
					store[i+1]='\0';
					i=-1;
					tok=store;
					while(isspace(tok[0]))
					{
						tok=tok.substr(1, tok.size());
					}
					op<<tok<<endl;
					store[0]='\0';
					lex_state=1;
				}
				break;
				// case 15 accepts relational operator.
				case 15:
				{
					tok='\0';
					store[i+1]='\0';
					i=-1;
					tok=store;
					while(isspace(tok[0]))
					{
						tok=tok.substr(1, tok.size());
					}
					op<<tok<<endl;
					store[0]='\0';
					lex_state=1;
				}
				break;
				// case 16 accepts relational operator.
				case 16:
				{
					tok='\0';
					store[i+1]='\0';
					i=-1;
					tok=store;
					while(isspace(tok[0]))
					{
						tok=tok.substr(1, tok.size());
					}
					op<<tok<<endl;
					store[0]='\0';
					lex_state=1;
				}
				break;
				// case 18 accepts relational operator.
				case 18:
				{
					tok='\0';
					store[i+1]='\0';
					i=-1;
					tok=store;
					while(isspace(tok[0]))
					{
						tok=tok.substr(1, tok.size());
					}
					op<<tok<<endl;
					store[0]='\0';
					lex_state=1;
				}
				break;
				// case 19 accepts general punction.
				case 19:
				{
					tok='\0';
					store[i+1]='\0';
					tok=store;
					while(isspace(tok[0]))
					{
						tok=tok.substr(1, tok.size());
					}
					
					op<<tok<<endl;	
					store[0]='\0';
					lex_state=1;
					i=-1;
				}
				break;
				// case 20 accepts general punction.
				case 20:
				{
					tok='\0';
					store[i]='\0';
					i=-1;
					tok=store;
					/* Since we need to back up in state 20
					 * cp-- is done. This is implemented
					 * logically and not taken from the
					 * symbol table
					 */ 
					cp--;
					while(isspace(tok[0]))
					{
						tok=tok.substr(1, tok.size());
					}
					
					op<<tok<<endl;	
					store[0]='\0';
					lex_state=1;
					i=-1;
				}
				break;
			}
			i++;
		}
/*
 * This part of the code will execute if end of line has been reached
 * while lex_state value is "2". The value of "2" means that the 
 * current state is 2 which is for accepting identifers and keyword.
 * For example 
 * begin
 * 	if(...
 * 
 * Here begin is a keyword. The function takes the entire line 
 * and starts at "b" and continues to accept characters till it as 
 * reached the end of line. Before going to the next line the token
 * "begin" must be accepted since end of line is considered as 
 * white space according to the symbol table and transition 
 * must be made.
 * 
 * This transition cannot be made in the for loop  given above
 * as the loop exits when it encounters the end of line and 
 * moves to the next line.
 */ 		
		if((lex_state==2))
		{
			tok='\0';
			store[i]='\0';
			tok=store;
			while(isspace(tok[0]))
			{
				tok=tok.substr(1, tok.size());
			}
			i=-1;
			op<<tok<<endl;
			store[0]='\0';
			lex_state=1;
		}
		i=0;
	}
}


string getexp()
{
	int t;
	string a;
	ifstream ip1("data.txt");	
	for(t=0; t<=tok1;t++)
		getline(ip1, a);
	tok1++;
	return a;
}

void backup()
{
	if(tok1>0)
		tok1--;
}

